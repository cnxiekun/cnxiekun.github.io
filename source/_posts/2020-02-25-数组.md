---
title: 数组
date: 2020-02-25 23:25:10
categories: 数据结构与算法
tags: 数组
description:
---

**数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**

## 基本概念

通过了解以下几个关键词，掌握数组。

1. **线性表** (Linear List): 数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。

![线性表](2020-02-25-数组/线性表.jpg)

<!--more-->

而与它相对立的概念是**非线性表**，比如二叉树、堆、图等。在非线性表中，数据之间并不是简单的前后关系。

![非线性表](2020-02-25-数组/非线性表.jpg)

2. **连续的内存空间和相同类型的数据**: “杀手锏”特性——`随机访问`。
但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中 `删除`、`插入` 一个数据，为了保证连续性，就需要做大量的数据搬移工作。

## 数组是如何实现根据下标随机访问数组元素?

以一个长度为 10 的 `int` 类型的数组 `int[] a = new int[10]` 举例。在下图中，计算机给数组 `a[10]`，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 `base_address = 1000`。

![数组存储空间](2020-02-25-数组/数组存储空间.jpg)

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址:

```java
a[i]_address = base_address + i * data_type_size
```

其中 `data_type_size` 表示数组中每个元素的大小。这里，数组中存储的是 `int` 类型数据，所以 `data_type_size` 就为 4 个字节。

> 特别纠正一个“错误”：在面试的时候，会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 $O(1)$；数组适合查找，查找时间复杂度为 $O(1)$”。
实际上，这种表述不准确。数组是适合查找操作，但是查找的时间复杂度并不为 $O(1)$。即便是排好序的数组，用二分查找，时间复杂度也是 $O(logn)$。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 $O(1)$。

## 低效的 `插入` 和 `删除`

数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。究竟为什么会导致低效？又有哪些改进方法呢？

### 插入操作

假设数组的长度为 $n$，现在，如果我们需要将一个数据插入到数组中的第 $k$ 个位置。为了把第 $k$ 个位置腾出来，给新来的数据，我们需要将第 $k-n$ 这部分的元素都顺序地往后挪一位。

如果在数组的末尾插入元素，不需要移动数据，时间复杂度为 $O(1)$。如果在数组的开头插入元素，所有的数据都需要依次往后移动一位，时间复杂度为 $O(n)$。 因为在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 $(1+2+\cdots+n)/n=O(n)$。

如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 $k$ 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 $k$ 个位置，为了避免大规模的数据搬移，有一个简单的办法，直接将第 $k$ 位的数据搬移到数组元素的最后，把新的元素直接放入第 $k$ 个位置。

假设数组 `a[10]` 中存储了如下 5 个元素：a，b，c，d，e。现在需要将元素 `x` 插入到第 3 个位置。我们只需要将 `c` 放入到 `a[5]`，将 `a[2]` 赋值为 `x` 即可。最后，数组中的元素如下： a，b，x，d，e，c。

![数组插入](2020-02-25-数组/数组插入.jpg)

利用这种处理技巧，在特定场景下，在第 $k$ 个位置插入一个元素的时间复杂度就会降为 $O(1)$。

### 删除操作

跟插入数据类似，如果要删除第 $k$ 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。实际上，在某些特殊场景下，并不一定非得追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？

例如，数组 `a[10]` 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，依次删除 a，b，c 三个元素。

![数组删除](2020-02-25-数组/数组删除.jpg)

为了避免 d，e，f，g，h 这几个数据会被搬移三次，可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

## 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 `a` 来表示数组的首地址，`a[0]` 就是偏移为 0 的位置，也就是首地址，`a[k]` 就表示偏移 `k` 个 `type_size` 的位置，所以计算 `a[k]` 的内存地址只需要用这个公式：

```java
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 `a[k]`的内存地址就会变为：

```java
a[k]_address = base_address + (k - 1) * type_size
```

对比两个公式，不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

不过有人认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以有人觉得最主要的原因可能是历史原因。`C` 语言设计者用 0 开始计数数组下标，之后的 `Java`、`JavaScript` 等高级语言都效仿了 `C` 语言，或者说，为了在一定程度上减少 `C` 语言程序员学习 `Java` 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 `Matlab`。甚至还有一些语言支持负数下标，比如 `Python`。

> 参考资料：[王争——数组：为什么很多编程语言中数组都从0开始编号？](https://time.geekbang.org/column/article/40961)
