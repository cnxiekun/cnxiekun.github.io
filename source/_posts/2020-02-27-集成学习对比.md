---
title: 集成学习对比
date: 2020-02-27 15:07:11
categories: 机器学习
tags: [RF, GBDT, XGBoost]
description:
---

**集成学习（Ensemble Learning）是通过结合多个基学习器的预测结果来改善单个学习器的泛化能力和鲁棒性。**

根据基学习器的生成方式，集成学习方法大致分为两类：

1. 基学习器之间存在强依赖关系、必须串行生成
2. 基学习器间不存在强依赖关系、可同时生成的并行化方法

前者的代表就是 Boosting (如 `GBDT`、`XGBoost`)，后者的代表是 Bagging (如 `RF`)。

<!--more-->

## RF

Bagging 可以简单的理解为：样本放回抽样，多数表决（分类）或简单平均（回归），同时Bagging的基学习器之间属于并列生成，不存在强依赖关系。

RF (Random Forest，随机森林) 是 Bagging 的扩展变体，以决策树为基学习器，且在决策树的训练过程中引入了随机特征选择，因此 RF 可以概括为以下四个部分：

1. 样本放回抽样
2. 特征随机选择
3. 构建决策树
4. 随机森林投票/平均

特征随机选择是指在决策树的构建中，会从样本集的特征集合中随机选择部分特征，然后再从这个子集中选择最优的属性用于划分，这种随机性导致随机森林的偏差会有稍微的增加，但是由于随机森林的“平均”特性，会使得它的方差减小，而且方差的减小补偿了偏差的增大，因此总体而言是更好的模型。

RF 重要特点：

1. 每棵决策树都最大可能的进行生长而不进行剪枝
2. 不用交叉验证或者使用一个独立的测试集获得无偏估计，RF 可以在内部进行评估——每个基学习器只使用了训练集中约63.2%的样本，剩下约36.8% ($1/e$)的样本可用做验证集来对其泛化性能进行“包外估计” (out-of-bag)

RF 优缺点：

1. 优点：
    - 在数据集上表现较好（训练速度、预测准确率）
    - 能够处理很高维的数据，并且不用特征选择，能给出特征的重要性
    - 易并行训练
2. 缺点：
    - 在噪声较大的分类或者回归问题上易过拟合

## GBDT

Boosting 是一种与 Bagging 类似的技术，但 Boosting 是通过关注被已有分类器错分的那些数据来获得新的分类器——串行生成基分类器。Boosting 分类的结果是基于所有分类器的加权求和，每个分类器权重并不相等，每个权重代表对应的分类器在上一轮迭代中的成功度，而 Bagging 中的分类器权值是一样的。

GBDT (Gradient Boosting Decision Tree, 梯度提升树) 与传统的 Boosting 区别较大，它的每一次计算都是为了减少上一次的残差。为了消除残差，在残差减小的梯度方向上建立模型，每个新的模型的建立是为了使得之前的模型的残差往梯度下降的方法，与传统的 Boosting 中关注正确错误的样本加权有着很大的区别。

在 GradientBoosting 算法中，利用损失函数的负梯度方向在当前模型的值作为残差的近似值，进而拟合一棵 CART 回归树。GBDT 的会累加所有树的结果，而这种累加是无法通过分类完成的，因此 GBDT 的树都是 CART 回归树，而不是分类树。

GBDT 优缺点（与RF有点类似）：

1. 优点：
    - 性能在 RF 的基础上“有一定提升”
    - 能灵活的处理各种类型的数据
    - 在相对较少的调参时间下，预测的准确度较高
2. 缺点：
    - 基学习器之前存在串行关系，难以并行训练

## XGBoost

XGBoost 的性能在 GBDT 上又有一步提升，毕竟比赛神器。XGBoost 能够自动地运用 CPU 的多线程进行并行计算，同时在算法精度上也进行了精度的提高。

由于 GBDT 在合理的参数设置下，往往要生成一定数量的树才能达到令人满意的准确率，在数据集较复杂时，模型可能需要几千次迭代运算。但是 XGBoost 利用并行的 CPU 更好的解决了这个问题。

## GBDT 与 XGBoost区别

1. **基学习器:** 传统的 GBDT 以 CART 树作为基学习器，XGBoost 还支持线性分类器，这个时候XGBoost相当于 L1 和 L2 正则化的 Logistics Regression（分类）或者 Linear Regression（回归）
2. **导数信息:** 传统的 GBDT 在优化的时候只用到一阶导数信息，XGBoost 则对代价函数进行了二阶泰勒展开，得到一阶和二阶导数
3. **正则项:** XGBoost 在代价函数中加入了正则项，用于控制模型的复杂度。从权衡方差偏差来看，它降低了模型的方差，使学习出来的模型更加简单，防止过拟合，这也是 XGBoost 优于传统 GBDT 的一个特性
4. **列抽样:** XGBoost 借鉴了随机森林的做法，支持列抽样，不仅防止过拟合，还能减少计算
5. **缺失值处理:** 对于特征的值有缺失的样本，XGBoost 可以自动学习出它的分裂方向
6. **并行:** XGBoost的并行不是 tree 粒度的并行，XGBoost 也是一次迭代完才能进行下一次迭代的。XGBoost 的并行是在`特征粒度`上的。决策树的学习最耗时的一个步骤就是对特征的值进行排序——要确定最佳分割点，XGBoost 在训练之前，预先对数据进行了排序，然后保存为 block 结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个 block 结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行

**Remark:** 相关面试问答可以参考：
1. [N问GBDT](https://blog.csdn.net/u014465639/article/details/73912614)
2. [RF、GBDT、XGBoost常见面试题整理](https://zhuanlan.zhihu.com/p/34679467)
